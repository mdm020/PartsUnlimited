name: CI/CD Pipeline with Security

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: read
  security-events: write

jobs:
  # Security Scanning
  security:
    name: üîí Security Scan
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: csharp
        queries: security-extended,security-and-quality
    
    # For .NET Framework projects, use autobuild
    - name: Autobuild for CodeQL
      uses: github/codeql-action/autobuild@v3
    
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3

  # Build and Test
  build-test:
    name: üèóÔ∏è Build and Test
    runs-on: windows-latest

    steps:
      # Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4

      # Setup NuGet and restore packages
      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2

      - name: Restore NuGet packages
        run: |
          nuget restore PartsUnlimited.sln -PackagesDirectory packages

      # Setup MSBuild
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      # Build solution & publish website
      - name: Build & Publish Website
        run: |
          msbuild src\PartsUnlimitedWebsite\PartsUnlimitedWebsite.csproj `
            /p:Configuration=Release `
            /p:Platform=AnyCPU `
            /p:DeployOnBuild=true `
            /p:WebPublishMethod=FileSystem `
            /p:PublishUrl=..\..\artifact `
            /p:DeployTarget=WebPublish `
            /p:PackageRestore=true `
            /p:RestorePackagesPath=packages

      # Build test projects
      - name: Build Test Projects
        run: |
          msbuild test\PartsUnlimited.UnitTests\PartsUnlimited.UnitTests.csproj `
            /p:Configuration=Release `
            /p:Platform=AnyCPU `
            /p:PackageRestore=true `
            /p:RestorePackagesPath=packages
        continue-on-error: true

      # Run MSTest unit tests
      - name: Run Unit Tests
        shell: pwsh
        run: |
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          $vstest = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -find **\vstest.console.exe |
            Select-Object -First 1
          
          $testDlls = Get-ChildItem -Path "test" -Filter "*UnitTests.dll" -Recurse | 
            Where-Object { $_.FullName -like "*\bin\Release\*" } |
            Select-Object -ExpandProperty FullName
          
          if ($testDlls) {
            & "$vstest" $testDlls /Platform:x64 /Logger:trx
          }
        continue-on-error: true

      # Vulnerability Check on Dependencies
      - name: Check for Vulnerable Dependencies
        shell: pwsh
        run: |
          Write-Host "=== SECURITY: Checking for vulnerable packages ===" -ForegroundColor Yellow
          
          # Check for known vulnerable packages
          $vulnerablePackages = @{
            "bootstrap" = "3.3.7"
            "jQuery" = "3.1.1"
            "Newtonsoft.Json" = "9.0.1"
            "Microsoft.Owin" = "3.0.1"
          }
          
          $packagesConfig = Get-Content "src\PartsUnlimitedWebsite\packages.config" -Raw
          $foundVulnerabilities = $false
          
          foreach ($pkg in $vulnerablePackages.GetEnumerator()) {
            if ($packagesConfig -match "package id=`"$($pkg.Name)`"") {
              Write-Host "‚ö†Ô∏è  WARNING: $($pkg.Name) $($pkg.Value) has known vulnerabilities" -ForegroundColor Red
              Write-Host "   Consider upgrading to latest version" -ForegroundColor Yellow
              $foundVulnerabilities = $true
            }
          }
          
          if (-not $foundVulnerabilities) {
            Write-Host "‚úÖ No highly vulnerable packages detected" -ForegroundColor Green
          }

      # Secret Scanning
      - name: Scan for Secrets
        shell: pwsh
        run: |
          Write-Host "=== SECURITY: Scanning for hardcoded secrets ===" -ForegroundColor Yellow
          
          $patterns = @(
            '(?i)password\s*=\s*["''][^"\'\n]{8,}["'']',
            '(?i)connectionString\s*=\s*["''][^"\'\n]{20,}["'']',
            '(?i)api[_-]?key\s*=\s*["''][^"\'\n]{10,}["'']',
            '(?i)secret[_-]?key\s*=\s*["''][^"\'\n]{10,}["'']',
            '(?i)token\s*=\s*["''][^"\'\n]{10,}["'']',
            'aws[_-]?key\s*=\s*["''][^"\'\n]{10,}["'']'
          )
          
          $filesToScan = @(
            "**/*.config",
            "**/*.json", 
            "**/*.cs",
            "**/*.cshtml"
          )
          
          $foundSecrets = $false
          foreach ($file in (Get-ChildItem -Path $filesToScan -Recurse -File)) {
            $content = Get-Content $file.FullName -Raw
            foreach ($pattern in $patterns) {
              if ($content -match $pattern) {
                Write-Host "‚ùå POTENTIAL SECRET FOUND:" -ForegroundColor Red
                Write-Host "   File: $($file.FullName)" -ForegroundColor Yellow
                Write-Host "   Pattern: $pattern" -ForegroundColor Gray
                $foundSecrets = $true
              }
            }
          }
          
          if ($foundSecrets) {
            Write-Host "`n‚ùå SECURITY ISSUE: Hardcoded secrets detected!" -ForegroundColor Red
            Write-Host "   Remove secrets from code and use secure storage" -ForegroundColor Yellow
            exit 1
          } else {
            Write-Host "‚úÖ No hardcoded secrets found" -ForegroundColor Green
          }

      # Verify artifact
      - name: Verify artifact folder
        run: |
          if (Test-Path "artifact") {
            Write-Host "‚úÖ Artifact folder created successfully"
          } else {
            Write-Host "‚ùå Artifact folder not found"
            exit 1
          }

      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: PartsUnlimited-Web
          path: artifact

  # Deploy to IIS
  deploy:
    name: üöÄ Deploy to Production
    needs: [security, build-test]
    runs-on: self-hosted
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      # Download build artifacts
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: PartsUnlimited-Web
          path: ./artifacts
      
      # Simple file copy to IIS path
      - name: Deploy to IIS
        shell: powershell
        run: |
          $sitePath = "D:\inetpub\wwwroot\partsUnlimited"
          
          Write-Host "üöÄ Deploying to: $sitePath"
          
          # Ensure directory exists
          if (!(Test-Path $sitePath)) {
              New-Item -ItemType Directory -Path $sitePath -Force
          }
          
          # Copy files (overwrite existing)
          Copy-Item -Path ".\artifacts\*" -Destination $sitePath -Recurse -Force
          
          Write-Host "‚úÖ Deployment completed!"
          Write-Host "üåê Application available at: http://localhost:8089"
