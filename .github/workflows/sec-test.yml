name: CI/CD Pipeline with Security

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  # 1. SECURITY ANALYSIS FIRST
  security-analysis:
    name: üîí Security & Code Analysis
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    # CodeQL Static Security Analysis
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: csharp
        queries: security-extended,security-and-quality
    
    - name: Setup MSBuild for CodeQL
      uses: microsoft/setup-msbuild@v2
    
    - name: Build for CodeQL Analysis
      run: |
        msbuild PartsUnlimited.sln `
          /p:Configuration=Debug `
          /p:Platform=AnyCPU `
          /p:RunCodeAnalysis=true `
          /verbosity:minimal
    
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
    
    # Quick Security Checks
    - name: Quick Security Scan
      shell: pwsh
      run: |
        Write-Host "=== SECURITY SCAN ===" -ForegroundColor Yellow
        
        # Check for hardcoded connection strings
        $webConfig = "src\PartsUnlimitedWebsite\Web.config"
        if (Test-Path $webConfig) {
          try {
            $xml = [xml](Get-Content $webConfig)
            $connectionStrings = $xml.configuration.connectionStrings.add
            
            if ($connectionStrings) {
              Write-Host "Found connection strings:" -ForegroundColor Cyan
              foreach ($cs in $connectionStrings) {
                Write-Host "  - $($cs.name)" -ForegroundColor Gray
              }
              Write-Host "`n‚ö†Ô∏è  Review connection strings for production" -ForegroundColor Yellow
            }
          } catch {
            Write-Host "Could not parse web.config" -ForegroundColor Gray
          }
        }
        
        # Check for common sensitive patterns
        Write-Host "`n=== Checking for sensitive patterns ===" -ForegroundColor Yellow
        $sensitivePatterns = @(
          "password\s*=",
          "pwd\s*=",
          "secret\s*=",
          "token\s*="
        )
        
        $found = $false
        $configFiles = Get-ChildItem -Path "src" -Filter "*.config" -Recurse
        
        foreach ($file in $configFiles) {
          $content = Get-Content $file.FullName -Raw
          foreach ($pattern in $sensitivePatterns) {
            if ($content -match $pattern) {
              Write-Host "‚ö†Ô∏è  Found '$pattern' in $($file.Name)" -ForegroundColor Yellow
              $found = $true
            }
          }
        }
        
        if (-not $found) {
          Write-Host "‚úÖ No obvious hardcoded secrets found" -ForegroundColor Green
        }
        
        Write-Host "`n‚úÖ Security scan completed" -ForegroundColor Green

  # 2. BUILD AND TEST (depends on security passing)
  build-and-test:
    name: üèóÔ∏è Build and Test
    runs-on: windows-latest
    needs: security-analysis  # Wait for security analysis
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # Setup build tools
    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2

    - name: Restore NuGet packages
      run: |
        nuget restore PartsUnlimited.sln -PackagesDirectory packages

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    # Build main website
    - name: Build Website
      run: |
        msbuild src\PartsUnlimitedWebsite\PartsUnlimitedWebsite.csproj `
          /p:Configuration=Release `
          /p:Platform=AnyCPU `
          /p:DeployOnBuild=true `
          /p:WebPublishMethod=FileSystem `
          /p:PublishUrl=..\..\artifact `
          /p:DeployTarget=WebPublish `
          /p:PackageRestore=true `
          /p:RestorePackagesPath=packages

    # Build and run tests
    - name: Build Test Projects
      run: |
        msbuild test\PartsUnlimited.UnitTests\PartsUnlimited.UnitTests.csproj `
          /p:Configuration=Release `
          /p:Platform=AnyCPU `
          /p:PackageRestore=true `
          /p:RestorePackagesPath=packages
      continue-on-error: true

    - name: Run Unit Tests
      shell: pwsh
      run: |
        $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
        $vstest = & $vswhere -latest -products * -requires Microsoft.Component.MSBuild -find **\vstest.console.exe | Select-Object -First 1
        
        if ($vstest -and (Test-Path $vstest)) {
          $testDlls = Get-ChildItem -Path "test" -Filter "*UnitTests.dll" -Recurse | 
            Where-Object { $_.FullName -like "*\bin\Release\*" } |
            Select-Object -ExpandProperty FullName
          
          if ($testDlls) {
            & "$vstest" $testDlls /Platform:x64 /Logger:trx
            Write-Host "‚úÖ Tests completed" -ForegroundColor Green
          } else {
            Write-Host "‚ö†Ô∏è  No test DLLs found" -ForegroundColor Yellow
          }
        } else {
          Write-Host "‚ö†Ô∏è  vstest.console.exe not found" -ForegroundColor Yellow
        }
      continue-on-error: true

    # Verify artifact
    - name: Verify Build Output
      shell: pwsh
      run: |
        if (Test-Path "artifact") {
          $fileCount = (Get-ChildItem -Path "artifact" -Recurse -File | Measure-Object).Count
          Write-Host "‚úÖ Build successful - $fileCount files in artifact" -ForegroundColor Green
          Get-ChildItem -Path "artifact" -File | Select-Object -First 5 Name
        } else {
          Write-Host "‚ùå Build failed - artifact folder not found" -ForegroundColor Red
          exit 1
        }

    # Upload artifact for deployment
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: web-app
        path: artifact
        retention-days: 7

  # 3. DEPLOY TO PRODUCTION (only on main/master)
  deploy-production:
    name: üöÄ Deploy to Production
    needs: build-and-test
    runs-on: self-hosted
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    environment: production
    
    steps:
    # Download artifact
    - name: Download Artifact
      uses: actions/download-artifact@v4
      with:
        name: web-app
        path: ./deploy-artifacts
    
    # Simple deployment - just copy files
    - name: Deploy to IIS
      shell: pwsh
      run: |
        $sitePath = "D:\inetpub\wwwroot\partsUnlimited"
        
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "üöÄ PRODUCTION DEPLOYMENT" -ForegroundColor Cyan
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "Target: $sitePath" -ForegroundColor Gray
        Write-Host "Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Gray
        Write-Host ""
        
        # Create backup of existing (optional)
        $backupPath = "${sitePath}_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
        if (Test-Path $sitePath -PathType Container) {
          if ((Get-ChildItem $sitePath | Measure-Object).Count -gt 0) {
            try {
              Copy-Item -Path $sitePath -Destination $backupPath -Recurse -Force -ErrorAction SilentlyContinue
              Write-Host "üì¶ Backup created: $backupPath" -ForegroundColor Gray
            } catch {
              Write-Host "‚ö†Ô∏è  Could not create backup" -ForegroundColor Yellow
            }
          }
        }
        
        # Ensure directory exists
        if (!(Test-Path $sitePath)) {
          New-Item -ItemType Directory -Path $sitePath -Force | Out-Null
          Write-Host "Created directory: $sitePath" -ForegroundColor Gray
        }
        
        # Deploy new files
        Write-Host "üì§ Deploying files..." -ForegroundColor Gray
        $sourceFiles = Get-ChildItem -Path ".\deploy-artifacts" -Recurse -File
        Copy-Item -Path ".\deploy-artifacts\*" -Destination $sitePath -Recurse -Force
        
        Write-Host "‚úÖ Deployed $($sourceFiles.Count) files" -ForegroundColor Green
        
        # Final message
        Write-Host ""
        Write-Host "========================================" -ForegroundColor Green
        Write-Host "‚úÖ DEPLOYMENT SUCCESSFUL" -ForegroundColor Green
        Write-Host "========================================" -ForegroundColor Green
        Write-Host "üåê Application: http://localhost:8089" -ForegroundColor Cyan
        Write-Host "üïê Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Gray
        
        if (Test-Path $backupPath) {
          Write-Host "üì¶ Backup: $backupPath" -ForegroundColor Gray
        }
    
    # Optional: Health check
    - name: Health Check
      shell: pwsh
      run: |
        Write-Host "Running health check..."
        
        $url = "http://localhost:8089"
        $maxAttempts = 5
        
        for ($i = 1; $i -le $maxAttempts; $i++) {
          Write-Host "Attempt $i/$maxAttempts to reach $url"
          
          try {
            $response = Invoke-WebRequest -Uri $url -Method Head -TimeoutSec 10 -ErrorAction Stop
            if ($response.StatusCode -eq 200) {
              Write-Host "‚úÖ Site is responding (HTTP $($response.StatusCode))" -ForegroundColor Green
              break
            }
          } catch {
            if ($i -eq $maxAttempts) {
              Write-Host "‚ö†Ô∏è  Site may be starting up slowly" -ForegroundColor Yellow
            } else {
              Start-Sleep -Seconds 5
            }
          }
        }
