name: PartsUnlimited CI/CD

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  SOLUTION_PATH: './PartsUnlimited.sln'
  BUILD_CONFIGURATION: 'Release'

jobs:
  build:
    name: Build and Test
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup NuGet
      uses: nuget/setup-nuget@v1
      with:
        nuget-version: 'latest'

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v1.1
      with:
        msbuild-architecture: x64

    - name: Restore NuGet packages
      run: nuget restore ${{ env.SOLUTION_PATH }}

    - name: Build solution
      run: msbuild ${{ env.SOLUTION_PATH }} ^
        /p:Configuration=${{ env.BUILD_CONFIGURATION }} ^
        /p:Platform="Any CPU" ^
        /p:DeployOnBuild=true ^
        /p:DeployDefaultTarget=WebPublish ^
        /p:WebPublishMethod=FileSystem ^
        /p:DeleteExistingFiles=True ^
        /p:publishUrl="${{ github.workspace }}\publish"

    - name: Run Unit Tests with MSTest
      shell: powershell
      run: |
        # Find MSTest runner
        $vsTestPath = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"
        if (-not (Test-Path $vsTestPath)) {
          $vsTestPath = "${env:ProgramFiles}\Microsoft Visual Studio\2022\Enterprise\Common7\IDE\Extensions\TestPlatform\vstest.console.exe"
        }
        if (-not (Test-Path $vsTestPath)) {
          Write-Host "Searching for vstest.console.exe..."
          $vsTestPath = Get-ChildItem -Path "${env:ProgramFiles(x86)}\Microsoft Visual Studio" -Filter "vstest.console.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName
        }

        # Create test results directory
        $testResultsDir = "${{ github.workspace }}\TestResults"
        New-Item -ItemType Directory -Path $testResultsDir -Force | Out-Null

        # Find test assemblies
        $testDlls = Get-ChildItem -Path "${{ github.workspace }}\test" -Filter "*Tests.dll" -Recurse | Where-Object { $_.FullName -like "*\bin\${{ env.BUILD_CONFIGURATION }}\*" -and $_.FullName -notlike "*\ref\*" }

        Write-Host "Found $($testDlls.Count) test assemblies:"
        $testDlls | ForEach-Object { Write-Host "  - $($_.FullName)" }

        if ($testDlls.Count -eq 0) {
          Write-Warning "No test assemblies found. Skipping tests."
          exit 0
        }

        # Run tests
        if (Test-Path $vsTestPath) {
          Write-Host "Using VSTest at: $vsTestPath"
          & $vsTestPath $testDlls.FullName `
            /Logger:"trx;LogFileName=test-results.trx" `
            /ResultsDirectory:$testResultsDir `
            /Platform:x64
        } else {
          Write-Host "VSTest not found, using dotnet test..."
          $testProjects = Get-ChildItem -Path "${{ github.workspace }}\test" -Filter "*Tests.csproj" -Recurse
          foreach ($project in $testProjects) {
            Write-Host "Testing: $($project.Name)"
            dotnet test $project.FullName `
              --configuration ${{ env.BUILD_CONFIGURATION }} `
              --no-build `
              --logger "trx;LogFileName=$testResultsDir\$($project.BaseName)-results.trx" `
              --results-directory $testResultsDir
          }
        }

        Write-Host "`nTest execution completed"
      continue-on-error: true

    - name: Check for test results
      if: always()
      id: check_tests
      shell: powershell
      run: |
        Write-Host "=== Searching for Test Results ==="
        $trxFiles = Get-ChildItem -Path "${{ github.workspace }}" -Filter "*.trx" -Recurse -ErrorAction SilentlyContinue

        if ($trxFiles.Count -gt 0) {
          Write-Host "Found $($trxFiles.Count) test result file(s):"
          $trxFiles | ForEach-Object {
            Write-Host "  - $($_.FullName) (Size: $($_.Length) bytes)"
          }
          echo "has_results=true" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "No test result files found"
          echo "has_results=false" >> $env:GITHUB_OUTPUT
        }

    - name: Parse and display test results
      if: always() && steps.check_tests.outputs.has_results == 'true'
      shell: powershell
      run: |
        Write-Host "`n=== Test Results Summary ===" -ForegroundColor Cyan

        $trxFiles = Get-ChildItem -Path "${{ github.workspace }}" -Filter "*.trx" -Recurse
        $totalTests = 0
        $totalPassed = 0
        $totalFailed = 0
        $totalSkipped = 0

        foreach ($file in $trxFiles) {
          Write-Host "`nProcessing: $($file.Name)" -ForegroundColor Yellow

          try {
            [xml]$trx = Get-Content $file.FullName
            $results = $trx.TestRun.ResultSummary

            $outcome = $results.outcome
            $total = [int]$results.Counters.total
            $executed = [int]$results.Counters.executed
            $passed = [int]$results.Counters.passed
            $failed = [int]$results.Counters.failed
            $notExecuted = $total - $executed

            Write-Host "  Total: $total | Passed: $passed | Failed: $failed | Skipped: $notExecuted"
            Write-Host "  Outcome: $outcome" -ForegroundColor $(if($outcome -eq "Completed") { "Green" } else { "Red" })

            $totalTests += $total
            $totalPassed += $passed
            $totalFailed += $failed
            $totalSkipped += $notExecuted

          } catch {
            Write-Host "  Could not parse test results: $_" -ForegroundColor Red
          }
        }

        Write-Host "`n=== Overall Summary ===" -ForegroundColor Cyan
        Write-Host "Total Tests: $totalTests"
        Write-Host "Passed: $totalPassed" -ForegroundColor Green
        Write-Host "Failed: $totalFailed" -ForegroundColor $(if($totalFailed -gt 0) { "Red" } else { "Green" })
        Write-Host "Skipped: $totalSkipped" -ForegroundColor Yellow

        $passRate = if($totalTests -gt 0) { [math]::Round(($totalPassed / $totalTests) * 100, 2) } else { 0 }
        Write-Host "Pass Rate: $passRate%" -ForegroundColor $(if($passRate -ge 80) { "Green" } elseif($passRate -ge 60) { "Yellow" } else { "Red" })

        $summary = @"
        ## Test Results Summary

        | Metric | Count |
        |--------|-------|
        | Total Tests | $totalTests |
        | ✅ Passed | $totalPassed |
        | ❌ Failed | $totalFailed |
        | ⏭️ Skipped | $totalSkipped |
        | Pass Rate | $passRate% |
        "@

        echo $summary >> $env:GITHUB_STEP_SUMMARY

        if ($totalFailed -gt 0) {
          Write-Host "`n❌ Build failed due to test failures" -ForegroundColor Red
          exit 1
        }

    - name: Upload Test Results as Artifact
      if: always() && steps.check_tests.outputs.has_results == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: |
          ${{ github.workspace }}/TestResults/**/*.trx
        if-no-files-found: warn
        retention-days: 30

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: partsunlimited-build
        path: ${{ github.workspace }}\publish
        retention-days: 7

  deploy:
    name: Deploy to IIS
    needs: build
    runs-on: self-hosted
    if: github.ref == 'refs/heads/master' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: partsunlimited-build
        path: C:\temp\PartsUnlimited\artifacts

    - name: Stop IIS Application Pool (safe)
      shell: powershell
      run: |
        Import-Module WebAdministration

        $appPoolName = "PartsUnlimitedAppPool"

        if (Test-Path "IIS:\AppPools\$appPoolName") {
          $state = (Get-WebAppPoolState -Name $appPoolName).Value
          if ($state -ne 'Stopped') {
            Write-Host "Stopping app pool $appPoolName (current state: $state)..."
            Stop-WebAppPool -Name $appPoolName
            Start-Sleep -Seconds 5
          } else {
            Write-Host "App pool $appPoolName already stopped; continuing."
          }
        } else {
          Write-Host "App pool $appPoolName does not exist yet; it will be created later."
        }

    - name: Backup current deployment
      shell: powershell
      run: |
        $deployPath = "C:\inetpub\wwwroot\PartsUnlimited"
        $backupRoot = "C:\inetpub\wwwroot"
        $timestamp  = Get-Date -Format 'yyyyMMdd_HHmmss'
        $backupPath = Join-Path $backupRoot ("PartsUnlimited_backup_{0}" -f $timestamp)

        if (Test-Path $deployPath) {
          Copy-Item -Path $deployPath -Destination $backupPath -Recurse -Force
          Write-Host "Backup created at: $backupPath"

          Get-ChildItem -Path $backupRoot -Filter "PartsUnlimited_backup_*" -Directory |
            Sort-Object CreationTime -Descending |
            Select-Object -Skip 5 |
            Remove-Item -Recurse -Force
        } else {
          Write-Host "No existing deployment found to back up."
        }

    - name: Clear deployment directory
      shell: powershell
      run: |
        $deployPath = "C:\inetpub\wwwroot\PartsUnlimited"

        if (Test-Path $deployPath) {
          Get-ChildItem -Path $deployPath -Recurse | Remove-Item -Force -Recurse
          Write-Host "Deployment directory cleared"
        } else {
          New-Item -ItemType Directory -Path $deployPath -Force | Out-Null
          Write-Host "Deployment directory created"
        }

    - name: Copy files to IIS
      shell: powershell
      run: |
        $sourcePath = "C:\temp\PartsUnlimited\artifacts"
        $deployPath = "C:\inetpub\wwwroot\PartsUnlimited"

        Copy-Item -Path "$sourcePath\*" -Destination $deployPath -Recurse -Force
        Write-Host "Files copied to deployment directory"

    - name: Configure IIS Application Pool
      shell: powershell
      run: |
        Import-Module WebAdministration

        $appPoolName = "PartsUnlimitedAppPool"

        if (-not (Test-Path "IIS:\AppPools\$appPoolName")) {
          New-WebAppPool -Name $appPoolName
          Write-Host "Application pool created"
        }

        Set-ItemProperty "IIS:\AppPools\$appPoolName" -Name "managedRuntimeVersion" -Value "v4.0"
        Set-ItemProperty "IIS:\AppPools\$appPoolName" -Name "managedPipelineMode"  -Value "Integrated"
        Set-ItemProperty "IIS:\AppPools\$appPoolName" -Name "enable32BitAppOnWin64" -Value $false
        Set-ItemProperty "IIS:\AppPools\$appPoolName" -Name "processModel.identityType" -Value "ApplicationPoolIdentity"

        Write-Host "Application pool configured"

    - name: Configure IIS Website
      shell: powershell
      run: |
        Import-Module WebAdministration

        $siteName   = "MyDotNetApp"
        $appPool    = "PartsUnlimitedAppPool"
        $physical   = "C:\inetpub\wwwroot\PartsUnlimited"
        $port       = 8080

        if (-not (Test-Path "IIS:\Sites\$siteName")) {
          New-Website -Name $siteName `
            -PhysicalPath $physical `
            -ApplicationPool $appPool `
            -Port $port
          Write-Host "Website created"
        } else {
          Set-ItemProperty "IIS:\Sites\$siteName" -Name "physicalPath"    -Value $physical
          Set-ItemProperty "IIS:\Sites\$siteName" -Name "applicationPool" -Value $appPool

          $binding = Get-WebBinding -Name $siteName -Port $port -ErrorAction SilentlyContinue
          if ($null -eq $binding) {
            New-WebBinding -Name $siteName -Protocol "http" -Port $port -IPAddress "*"
          }

          Write-Host "Website updated"
        }

    - name: Set folder permissions
      shell: powershell
      run: |
        $deployPath  = "C:\inetpub\wwwroot\PartsUnlimited"
        $appPoolName = "PartsUnlimitedAppPool"

        $acl = Get-Acl $deployPath
        $permission = "IIS AppPool\$appPoolName","ReadAndExecute","ContainerInherit,ObjectInherit","None","Allow"
        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
        $acl.SetAccessRule($accessRule)
        Set-Acl $deployPath $acl
        Write-Host "Permissions set for application pool identity"

    - name: Start IIS Application Pool
      shell: powershell
      run: |
        Import-Module WebAdministration

        $appPoolName = "PartsUnlimitedAppPool"

        if (Test-Path "IIS:\AppPools\$appPoolName") {
          $state = (Get-WebAppPoolState -Name $appPoolName).Value
          if ($state -ne 'Started') {
            Start-WebAppPool -Name $appPoolName
          }
        }

        $count = 0
        while ((Get-WebAppPoolState -Name $appPoolName).Value -ne "Started" -and $count -lt 30) {
          Start-Sleep -Seconds 1
          $count++
        }
        Write-Host "Application pool started"

    - name: Start IIS Website
      shell: powershell
      run: |
        Import-Module WebAdministration

        $siteName = "MyDotNetApp"

        Start-Website -Name $siteName

        Write-Host "Website started"

    - name: Warm up application
      shell: powershell
      run: |
        Start-Sleep -Seconds 5
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:8080" -UseBasicParsing -TimeoutSec 30
          Write-Host "Application warmed up. Status: $($response.StatusCode)"
        } catch {
          Write-Warning "Failed to warm up application: $_"
        }

    - name: Verify deployment
      shell: powershell
      run: |
        Import-Module WebAdministration

        $appPoolName = "PartsUnlimitedAppPool"
        $siteName    = "MyDotNetApp"

        $appPoolState = (Get-WebAppPoolState -Name $appPoolName).Value
        $websiteState = (Get-Website -Name $siteName).State

        Write-Host "Application Pool State: $appPoolState"
        Write-Host "Website State: $websiteState"

        if ($appPoolState -eq "Started" -and $websiteState -eq "Started") {
          Write-Host "✓ Deployment successful!"
          Write-Host "Application URL: http://localhost:8080"
        } else {
          Write-Error "Deployment verification failed!"
          exit 1
        }
